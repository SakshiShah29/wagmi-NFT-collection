import { ConnectButton } from "@rainbow-me/rainbowkit";
import type { NextPage } from "next";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import {
  useAccount,
  useBalance,
  useConnect,
  useContractRead,
  useContractWrite,
  useNetwork,
  usePrepareContractWrite,
  useWaitForTransaction,
} from "wagmi";
import { useIsMounted } from "../hooks/useIsMounted";
import { readContract } from "@wagmi/core";
import { useEffect, useState } from "react";
import { NFTS_CONTRACT_ADDRESS, abi } from "../constants/index";
import { parseEther } from "viem";

const Home: NextPage = () => {
  const isMounted = useIsMounted();
  const [presaleStarted, setPresaleStarted] = useState(false);
  const [contractOwner, setContractOwner] = useState(false);
  const [totalTokensMinted, setTotalTokensMinted] = useState(0);
  const { address, connector: activeConnector, isConnected } = useAccount();

  const { error } = useConnect();

  const { chain, chains } = useNetwork();

  /**
   * presaleMint: Mint an NFT during the presale
   */
  const { config: presaleConfig, error: contractPresaleError } =
    usePrepareContractWrite({
      address: NFTS_CONTRACT_ADDRESS,
      abi: abi,
      functionName: "presaleMint",
      value: parseEther("0.001"),
    });
  const { write: presaleWrite, data: presaleData } =
    useContractWrite(presaleConfig);

  const { isLoading: presaleTxLoading, isSuccess: presaleMintSuccess } =
    useWaitForTransaction({
      hash: presaleData?.hash,
    });
  // const presaleMint = async () => {
  //   await presaleWrite?.();
  //   if(presaleMintSuccess){
  //         window.alert("Successfully minted the presale nft!")
  //       }else{
  //         window.alert("presale mint error!");
  //       }

  // };

  /**
   * publicMint: Mint an NFT after the presale
   */
  const { config: mintConfig, error: publicMintContractError } =
    usePrepareContractWrite({
      address: NFTS_CONTRACT_ADDRESS,
      abi: abi,
      functionName: "mint",
      value: parseEther("0.001"),
    });
  const { write: publicWrite, data: publicData } = useContractWrite(mintConfig);

  const { isLoading: publicTxLoading, isSuccess: publicMintSuccess } =
    useWaitForTransaction({
      hash: publicData?.hash,
    });

  /**
   * getOwner: calls the contract to retrieve the owner
   */
  const ownerAddress = useContractRead({
    address: NFTS_CONTRACT_ADDRESS,
    abi: abi,
    functionName: "owner",
    onSuccess(data) {
      console.log("Owner data:", data);
    },
  });
  console.log(ownerAddress.data);

  useEffect(() => {
    if (address === ownerAddress.data) {
      setContractOwner(true);
    }
  }, []);
  /**
   * tokenIds: calls the contract to retrieve the tokenIds
   */
  const tokenIDs = useContractRead({
    address: NFTS_CONTRACT_ADDRESS,
    abi: abi,
    functionName: "tokenIds",
    onSuccess(data: string) {
      console.log("token data:", parseInt(data));
    },
  });
  useEffect(() => {
    setTotalTokensMinted(parseInt(tokenIDs?.data));
  }, [setTotalTokensMinted]);
  /**
   * startPresale: starts the presale for the NFT Collection
   */
  const { config: startPresaleConfig, error: contractStartPresaleError } =
    usePrepareContractWrite({
      address: NFTS_CONTRACT_ADDRESS,
      abi: abi,
      functionName: "startPresale",
    });
  const { write: startPresaleWrite, data: startPresaleData } =
    useContractWrite(startPresaleConfig);

  const { isLoading: startPresaleTxLoading, isSuccess: presaleStartSuccess } =
    useWaitForTransaction({
      hash: startPresaleData?.hash,
    });
  // const startPresale=async()=>{
  //   await startPresaleWrite?.();
  //   if(startPresaleTxLoading){
  //     window.alert("Presale Started!");
  //   }
  //   setPresaleStarted(true);
  // }

  return (
    <div className={styles.container}>
      <Head>
        <title>RainbowKit App</title>
        <meta
          content="Generated by @rainbow-me/create-rainbowkit"
          name="description"
        />
        <link href="/favicon.ico" rel="icon" />
      </Head>

      {isMounted && (
        <main className={styles.main}>
          <div className="container">
            <ConnectButton />
            {isConnected ? (
              <div>
                <p>Total nfts minted are :{totalTokensMinted}</p>
                {/* Presale Minting button */}
                {presaleStarted && !presaleTxLoading && (
                  <button onClick={() => presaleWrite?.()}>Presale Mint</button>
                )}
                {presaleTxLoading && presaleData && (
                  <p>The transaction was sent! The hash:{presaleData.hash}</p>
                )}
                {contractPresaleError && (
                  <p>
                    Calling the presale minting function will fail for this
                    reason:{contractPresaleError.message}
                  </p>
                )}
                {presaleMintSuccess && <p>You successfully minted an nft!</p>}

                {/* Public Minting button */}
                {!presaleStarted && !publicTxLoading && (
                  <button onClick={() => publicWrite?.()}>Public Mint</button>
                )}
                {publicTxLoading && publicData && (
                  <p>The transaction was sent! The hash:{publicData.hash}</p>
                )}
                {publicMintContractError && (
                  <p>
                    Calling the presale minting function will fail for this
                    reason:{publicMintContractError.message}
                  </p>
                )}
                {publicMintSuccess && <p>You successfully minted an nft!</p>}

                {contractOwner && !startPresaleTxLoading && (
                  <button
                    onClick={() => {
                      startPresaleWrite?.();
                      setPresaleStarted(true);
                    }}
                  >
                    Start Presale
                  </button>
                )}
                {startPresaleTxLoading && startPresaleData && (
                  <p>
                    The transaction was sent! The hash:{startPresaleData.hash}
                  </p>
                )}
                {contractStartPresaleError && (
                  <p>
                    Calling the presale minting function will fail for this
                    reason:{contractStartPresaleError.message}
                  </p>
                )}
              </div>
            ) : (
              <h2>Not Connected</h2>
            )}
          </div>

          <section className="Balance">
            <h3>
              Balance: <span></span>
            </h3>{" "}
          </section>

          {chains && (
            <div className="Current_chain">
              Current chain:
              {isConnected ? (
                <span>{chains.map((chain) => chain.name)}</span>
              ) : (
                "Connect Wallet"
              )}
            </div>
          )}
        </main>
      )}

      <p className="error">{error && <span>{error.message}</span>}</p>
      {/* End of component */}
    </div>
  );
};

export default Home;
